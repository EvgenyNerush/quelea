// Для компиляции нужно включить поддержку концептов (доступна с GCC 8, осень 2019 года):
// g++ -fconcepts pic.cpp && ./a.out

// Почему бы вместо конфигов не писать каждый раз свой cpp файл?  Или вынести конфиг в config.hpp,
// если удастся сделать структуру pic.cpp общей для всех конфигураций? Это позволит без труда
// написать, например, конфиг с внешним полем (заданным через функцию) какого угодно вида, не
// занимаясь "велосипедостроением" по разбору конфиг-файла, созданием библиотек типичных огибающих
// и т. п.

// Можно сделать структуру pic.cpp довольно общей, но, скорее всего, при этом для того, чтобы она
// не зависила от сортов используемых частиц, придётся создать базовый класс - массив частиц одного
// сорта, и создать наследников этого класса (массив электронов со своим пушером, способом вывода в
// файл и т. п., массив ионов со своим способом размещения в памяти, пушером и т. д.), чего делать
// не хочется. Это просто усложнит код.

#include <iostream>
#include <functional>
#include <cmath>
#include "particles.hpp"

using namespace std;

double a0 = 1;
double dt = 0.1;
double t_end = M_PI;

Fields sine_ex(double t, Vec3<double> r) {
    return Fields( a0 * cos(t), 0, 0, 0, 0, 0);
}

// Например, нам нужны частицы такого вида - с индексом. Пушер, описанный в particles.cpp, с ними
// может работать: ему нужны только x, y, z, px, py, pz, g, остальные поля класса могут быть
// любыми. Здесь было бы достаточно duck typing-а, но концепты (1) дают понятный код, пользователю
// не надо вчитываться и догадываться, чего именно пушер хочет от частицы, (2) нет бардака, который
// можно было бы развести с просто "коллекцией" разных пушеров, которым нужны _разные_ частицы, (3)
// понятные сообщения компилятора в случае ошибок (я надеюсь).
class Indexed_particle {
    public:
    double x, y, z, px, py, pz, g;
    long index;
};

// Поскольку нам не нужно всё время менять шаг, заряд частицы или функцию, задающую поле, мы
// фиксируем эти параметры; остаётся только функция (lambda function) глобального времени и
// частицы, которую мы хотим "продвинуть".
auto pusher_f = [](double t, Indexed_particle& p) {
    return Vay_pusher_functional<Indexed_particle>::step(p, 1, dt, t, sine_ex);
};

int main() {
    Indexed_particle p;
    p.px = 0;
    for (double t = 0; t < t_end; t += dt) {
        cout << t << '\t' << p.px << '\n';
        pusher_f(t, p);
    }
    return 0;
}
